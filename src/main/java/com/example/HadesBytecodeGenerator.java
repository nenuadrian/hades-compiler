package com.example;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ALOAD;
import static org.objectweb.asm.Opcodes.GETSTATIC;
import static org.objectweb.asm.Opcodes.ILOAD;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
import static org.objectweb.asm.Opcodes.IRETURN;
import static org.objectweb.asm.Opcodes.ISTORE;
import static org.objectweb.asm.Opcodes.RETURN;
import static org.objectweb.asm.Opcodes.SIPUSH;
import static org.objectweb.asm.Opcodes.V1_8;

public class HadesBytecodeGenerator extends HadesBaseVisitor<Void> {
    private final ClassWriter classWriter;
    private final MethodVisitor methodVisitor;
    private int varCounter = 0;

    // Map to keep track of variable names and their corresponding indices
    private final java.util.Map<String, Integer> varMap = new java.util.HashMap<>();

    public HadesBytecodeGenerator() {
        // Set up ASM ClassWriter
        classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        classWriter.visit(V1_8, ACC_PUBLIC, "HadesProgram", null, "java/lang/Object", null);

        // Create default constructor
        MethodVisitor constructor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        constructor.visitCode();
        constructor.visitVarInsn(ALOAD, 0);
        constructor.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        constructor.visitInsn(RETURN);
        constructor.visitMaxs(1, 1);
        constructor.visitEnd();

        // Start the main method
        methodVisitor = classWriter.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
        methodVisitor.visitCode();
    }

    @Override
    public Void visitVarDeclaration(HadesParser.VarDeclarationContext ctx) {
        String varName = ctx.ID().getText();
        int value = Integer.parseInt(ctx.NUMBER().getText());

        // Assign an index to the variable and store its value
        int index = varCounter++;
        varMap.put(varName, index);

        // Load the constant value and store it in the corresponding index
        methodVisitor.visitIntInsn(SIPUSH, value);
        methodVisitor.visitVarInsn(ISTORE, index);

        return null;
    }

    @Override
    public Void visitPrintStatement(HadesParser.PrintStatementContext ctx) {
        String varName = ctx.ID().getText();

        // Get the variable index and load it to be printed
        if (varMap.containsKey(varName)) {
            int index = varMap.get(varName);
            methodVisitor.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            methodVisitor.visitVarInsn(ILOAD, index);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(I)V", false);
        } else {
            throw new RuntimeException("Variable " + varName + " is not defined.");
        }

        return null;
    }

    @Override
    public Void visitReturnStatement(HadesParser.ReturnStatementContext ctx) {
        String varName = ctx.ID().getText();

        // Get the variable index and return its value
        if (varMap.containsKey(varName)) {
            int index = varMap.get(varName);
            methodVisitor.visitVarInsn(ILOAD, index);
            methodVisitor.visitInsn(IRETURN);
        } else {
            throw new RuntimeException("Variable " + varName + " is not defined.");
        }

        return null;
    }

    public byte[] generateBytecode() {
        // End the main method
        methodVisitor.visitInsn(RETURN);
        methodVisitor.visitMaxs(2, varCounter);
        methodVisitor.visitEnd();

        classWriter.visitEnd();

        // Return the generated bytecode
        return classWriter.toByteArray();
    }
}
